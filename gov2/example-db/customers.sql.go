// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customers.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const selectAllEmbroideryCustomers = `-- name: SelectAllEmbroideryCustomers :many
with
    embroidery as (
        select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
        from "order".customers as cu
        where cu.form = 'Embroidery' or cu.form = 'embroidery'
    -- and completedat is not date::"0001-01-01"
    )
select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
from embroidery
where removed = false and visible = 1 and completed = false
order by rushed desc, orderdue desc
`

type SelectAllEmbroideryCustomersRow struct {
	ID          pgtype.UUID
	Name        pgtype.Text
	Description pgtype.Text
	Orderin     pgtype.Date
	Orderdue    pgtype.Date
	Rushed      pgtype.Bool
	Form        pgtype.Text
	Visible     pgtype.Int4
	Email       pgtype.Text
	Phone       pgtype.Text
	Completed   pgtype.Bool
	Removed     pgtype.Bool
	Completedat pgtype.Date
}

func (q *Queries) SelectAllEmbroideryCustomers(ctx context.Context) ([]SelectAllEmbroideryCustomersRow, error) {
	rows, err := q.db.Query(ctx, selectAllEmbroideryCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllEmbroideryCustomersRow
	for rows.Next() {
		var i SelectAllEmbroideryCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Orderin,
			&i.Orderdue,
			&i.Rushed,
			&i.Form,
			&i.Visible,
			&i.Email,
			&i.Phone,
			&i.Completed,
			&i.Removed,
			&i.Completedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllScreenPrintCustomers = `-- name: SelectAllScreenPrintCustomers :many
with
    screenprint as (
        select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
        from "order".customers as cu
        where cu.form = 'Screen Print' or cu.form = 'screen print'
    -- and completedat is not date::"0001-01-01"
    )
select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
from screenprint
where removed = false and visible = 1 and completed = false
order by rushed desc, orderdue desc
`

type SelectAllScreenPrintCustomersRow struct {
	ID          pgtype.UUID
	Name        pgtype.Text
	Description pgtype.Text
	Orderin     pgtype.Date
	Orderdue    pgtype.Date
	Rushed      pgtype.Bool
	Form        pgtype.Text
	Visible     pgtype.Int4
	Email       pgtype.Text
	Phone       pgtype.Text
	Completed   pgtype.Bool
	Removed     pgtype.Bool
	Completedat pgtype.Date
}

func (q *Queries) SelectAllScreenPrintCustomers(ctx context.Context) ([]SelectAllScreenPrintCustomersRow, error) {
	rows, err := q.db.Query(ctx, selectAllScreenPrintCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllScreenPrintCustomersRow
	for rows.Next() {
		var i SelectAllScreenPrintCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Orderin,
			&i.Orderdue,
			&i.Rushed,
			&i.Form,
			&i.Visible,
			&i.Email,
			&i.Phone,
			&i.Completed,
			&i.Removed,
			&i.Completedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllTransferCustomers = `-- name: SelectAllTransferCustomers :many
with
    transfer as (
        select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
        from "order".customers as cu
        where cu.form = 'Transfer' or cu.form = 'transfer'
    -- and completedat is not date::"0001-01-01"
    )
select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
from transfer
where removed = false and visible = 1 and completed = false
order by rushed desc, orderdue desc
`

type SelectAllTransferCustomersRow struct {
	ID          pgtype.UUID
	Name        pgtype.Text
	Description pgtype.Text
	Orderin     pgtype.Date
	Orderdue    pgtype.Date
	Rushed      pgtype.Bool
	Form        pgtype.Text
	Visible     pgtype.Int4
	Email       pgtype.Text
	Phone       pgtype.Text
	Completed   pgtype.Bool
	Removed     pgtype.Bool
	Completedat pgtype.Date
}

func (q *Queries) SelectAllTransferCustomers(ctx context.Context) ([]SelectAllTransferCustomersRow, error) {
	rows, err := q.db.Query(ctx, selectAllTransferCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllTransferCustomersRow
	for rows.Next() {
		var i SelectAllTransferCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Orderin,
			&i.Orderdue,
			&i.Rushed,
			&i.Form,
			&i.Visible,
			&i.Email,
			&i.Phone,
			&i.Completed,
			&i.Removed,
			&i.Completedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectCustomerByID = `-- name: SelectCustomerByID :one
select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
from "order".customers
where id = $1
`

func (q *Queries) SelectCustomerByID(ctx context.Context, id pgtype.UUID) (OrderCustomer, error) {
	row := q.db.QueryRow(ctx, selectCustomerByID, id)
	var i OrderCustomer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Orderin,
		&i.Orderdue,
		&i.Rushed,
		&i.Form,
		&i.Visible,
		&i.Email,
		&i.Phone,
		&i.Completed,
		&i.Removed,
		&i.Completedat,
	)
	return i, err
}

const selectLatestCompletedCustomers = `-- name: SelectLatestCompletedCustomers :many
with
    customers as (
        select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
        from "order".customers as cu
        where cu.completedat > now() - '30 days'::interval
    )
select id, name, description, orderin, orderdue, rushed, form, visible, email, phone, completed, removed, completedat
from customers
where visible = 1 and completed = true and removed = false
order by completedat desc, name asc
`

type SelectLatestCompletedCustomersRow struct {
	ID          pgtype.UUID
	Name        pgtype.Text
	Description pgtype.Text
	Orderin     pgtype.Date
	Orderdue    pgtype.Date
	Rushed      pgtype.Bool
	Form        pgtype.Text
	Visible     pgtype.Int4
	Email       pgtype.Text
	Phone       pgtype.Text
	Completed   pgtype.Bool
	Removed     pgtype.Bool
	Completedat pgtype.Date
}

func (q *Queries) SelectLatestCompletedCustomers(ctx context.Context) ([]SelectLatestCompletedCustomersRow, error) {
	rows, err := q.db.Query(ctx, selectLatestCompletedCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectLatestCompletedCustomersRow
	for rows.Next() {
		var i SelectLatestCompletedCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Orderin,
			&i.Orderdue,
			&i.Rushed,
			&i.Form,
			&i.Visible,
			&i.Email,
			&i.Phone,
			&i.Completed,
			&i.Removed,
			&i.Completedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
